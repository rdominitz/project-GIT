using Constants;
using Entities;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace QALogic
{
    public class LogicImpl : ILogic
    {
        private IMedTrainDBContext _db;
        private const double NORMAL_PROBABILITY = 0.7;

        private int _answerId;
        private readonly object syncLockAnswerId;

        public LogicImpl(IMedTrainDBContext db)
        {
            _db = db;
            _answerId = 1;
            syncLockAnswerId = new object();
        }

        public Tuple<string, List<Question>> getAutoGeneratedTest(string subject, Topic topic, User u, int numOfQuestions)
        {
            UserLevel uLvl = _db.getUserLevel(u.UserId, subject, topic.TopicId);
            if (uLvl == null)
            {
                uLvl = new UserLevel { UserId = u.UserId, level = Levels.DEFAULT_LVL, SubjectId = subject, TopicId = topic.TopicId, timesAnswered = 0, timesAnsweredCorrectly = 0 };
            }
            // get all questions with a matching topic and subject
            List<Question> questions = _db.getQuestions(subject, topic.TopicId);
            List<Question> normalQuestions = _db.getNormalQuestions(subject);
            // if there is no question matching the given subject and topic
            if (questions.Count + normalQuestions.Count < numOfQuestions)
            {
                return new Tuple<string, List<Question>>("Error - the provided subject and topic does not have enough questions.", null);
            }
            // select the appropriate amount of random questions

            List<Question> chooseFrom = new List<Question>();
            List<Question> normal = new List<Question>();
            List<Question> abnormal = new List<Question>();
            int levelDiff = 0;
            while (normal.Count < numOfQuestions * NORMAL_PROBABILITY && normalQuestions.Count != 0)
            {
                foreach (Question q in normalQuestions)
                {
                    if (q.level == uLvl.level - levelDiff || q.level == uLvl.level + levelDiff)
                    {
                        normal.Add(q);
                        chooseFrom.Add(q);
                    }
                }
                foreach (Question q in normal)
                {
                    normalQuestions.Remove(q);
                }
                levelDiff++;
            }
            int temp = levelDiff;
            levelDiff = 0;
            while (abnormal.Count < numOfQuestions * (1 - NORMAL_PROBABILITY) && questions.Count != 0)
            {
                foreach (Question q in questions)
                {
                    if (q.level == uLvl.level - levelDiff || q.level == uLvl.level + levelDiff)
                    {
                        abnormal.Add(q);
                        chooseFrom.Add(q);
                    }
                }
                foreach (Question q in abnormal)
                {
                    questions.Remove(q);
                }
                levelDiff++;
            }
            levelDiff = temp;
            while (normal.Count + abnormal.Count < numOfQuestions)
            {
                foreach (Question q in normalQuestions)
                {
                    if (q.level == uLvl.level - levelDiff || q.level == uLvl.level + levelDiff)
                    {
                        normal.Add(q);
                        chooseFrom.Add(q);
                    }
                }
                foreach (Question q in normal)
                {
                    normalQuestions.Remove(q);
                }
                levelDiff++;
            }
            List<Question> test = new List<Question>();
            for (int i = 0; i < numOfQuestions; i++)
            {
                // should see if there are questions of the relevant level
                // if so, prefer those the user did not answer
                // if answered all of them, select from those answered over a week ago
                // if none apply, increase level range from [a,b] to [a-1,b+1]
                Question q = selectRandomObject<Question>(chooseFrom);
                chooseFrom.Remove(q);
                test.Add(q);
            }
            return new Tuple<string, List<Question>>(Replies.SUCCESS, test);
        }

        public string answerAQuestion(User u, Question q, bool isNormal, int normalityCertaintyLVL, List<string> diagnoses, List<int> certainties)
        {
            bool correctAnswer = isNormal == q.normal;
            Dictionary<string, int> userLevels = new Dictionary<string, int>();
            foreach (string s in diagnoses)
            {
                UserLevel userLevel = _db.getUserLevel(u.UserId, q.SubjectId, s);
                bool alreadtExist = userLevel != null;
                if (userLevel == null)
                {
                    userLevel = new UserLevel { UserId = u.UserId, SubjectId = q.SubjectId, TopicId = s, level = Levels.DEFAULT_LVL, timesAnswered = 0, timesAnsweredCorrectly = 0 };
                }
                userLevels[s] = userLevel.level;
                userLevel.timesAnswered++;
                if (!isNormal && diagnoses.Contains(s))
                {
                    userLevel.timesAnsweredCorrectly++;
                }
                else if (!isNormal)
                {
                    correctAnswer = false;
                }
                if (alreadtExist)
                {
                    _db.updateUserLevel(userLevel);
                }
                else
                {
                    _db.addUserLevel(userLevel);
                }
            }
            // create a new answer instance and save to DB
            Answer a = new Answer { };
            lock (syncLockAnswerId)
            {
                a.AnswerId = _answerId;
                a.QuestionId = q.QuestionId;
                a.UserId = u.UserId;
                a.timeAdded = DateTime.Now;
                a.questionLevel = q.level;
                a.isCorrectAnswer = correctAnswer;
                a.normal = isNormal;
                a.normalityCertainty = normalityCertaintyLVL;
                List<DiagnosisCertainty> diagnosesCertainties = new List<DiagnosisCertainty>();
                for (int i = 0; !isNormal && i < diagnoses.Count; i++)
                {
                    DiagnosisCertainty dc = new DiagnosisCertainty
                    {
                        AnswerId = _answerId,
                        SubjectId = q.SubjectId,
                        TopicId = diagnoses[i],
                        certainty = certainties[i],
                        userLevel = userLevels[diagnoses[i]]
                    };
                    _db.addDiagnosisCertainty(dc);
                }
            }
            _db.addAnswer(a);
            // update question's fields
            q.timesAnswered++;
            if (correctAnswer)
            {
                q.timesAnsweredCorrectly++;
            }
            // update users level's fields
            _db.updateQuestion(q);
            _db.SaveChanges();
            return Replies.SUCCESS;
            // update user and question level if needed
        }

        private T selectRandomObject<T>(List<T> l)
        {
            Random rnd = new Random();
            return l.ElementAt(rnd.Next(l.Count));
        }
    }
}
